#! https://zhuanlan.zhihu.com/p/660799402
# CSAPP 0x02 程序的机器级表示
# 3.1 历史观点

Intel 中每个后处理器的设计都是后向兼容的。为了保持这种传统，指令集中有许多非常奇怪的东西。

Intel 处理器系列有很多名字，包括 `IA32（x86）`，也就是 *Intel 32 位体系结构*，以及最新的 `Intel64`，即 `IA32` 的 64 位扩展，也称为 `x86-64、x64、AMD64`。

# 3.2 程序编码

```shell
linux> gcc -Og -o p p1.c p2.c
```

- `-Og`：生成符合原始 C 代码整体结构的机器代码的优化等级，使用较高级别优化产生的机器代码和初始源代码之间的关系会非常难以理解。

## 3.2.1 机器级代码

对于机器级编程来说，其中**两种抽象**尤为重要：

- **由指令集体系结构或指令集架构来定义机器级程序的格式和行为**，*它定义了处理器状态、指令的格式，以及每条指令对状态的影响*。大多数 ISA 将程序的行为描述成好像每条指令都是按顺序执行的。但处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，不过可以采取措施保证整体行为与 ISA 指定的顺序执行的行为完全一致。
- **机器级程序使用的内存地址是虚拟地址**，*提供的内存模型看上去是一个非常大的字节数组*。而存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。

在机器代码中，一些通常对 C 语言程序员**隐藏的处理器状态**都是可见的：

- **程序计数器** `%rip`。
- **整数寄存器**文件包含 16 个命名的位置，分别存储 64 位的值。
- **条件码寄存器**保存着最近执行的算术或逻辑指令的状态信息。
- **一组向量寄存器**可以存放一个或多个整数或浮点数值。

**程序内存**包含：

- 程序的可执行机器代码。
- 操作系统需要的一些信息。
- 用来管理过程调用和返回的运行时栈。
- 用户分配的内存块。

在任意给定的时刻，只有有限的一部分虚拟地址被认为是合法的。x64 的虚拟地址是由 64 位的字来表示的。目前实现中，这些地址的高 16 位必须设置为 0，所以一个地址实际上能够指定的是 $2^{48}$ 范围内的一个字节。

## 3.2.2 代码示例

```shell
linux> gcc -Og -S mstore.c
linux> gcc -Og -c mstore.c
linux> objdump -d mstore.o
```

- `-S`：产生汇编文件 `mstore.s`。
- `-c`：产生二进制目标代码文件 `mstore.o`。
- `objdump -d`：使用反汇编器查看机器代码文件的内容，这些程序根据机器代码产生一种类似于汇编代码的格式。

**关于机器代码和它的反汇编表示的一些特性**：

- x64 的指令长度从 1 到 15 个字节不等。常用的指令以及操作数较少的指令所需的字节数少。
- 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令（如只有指令 `pushq ％rbx` 是以字节值 `53` 开头的）。
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。
- 反汇编器使用的指令命名规则与 GCC 生成的汇编代码使用的有些细微的差别。其中省略的很多指令结尾的 `q` 是大小指示符。

## 3.2.3 关于格式的注解

所有以 `.` 开头的行都是指导汇编器和链接器工作的伪指令，通常可以忽略这些行。

**程序中插入汇编代码有两种方法**：

- 我们可以编写完整的函数，放进一个独立的汇编代码文件中，让汇编器和链接器把它和用 C 语言书写的代码合并起来。 
- 我们可以使用 GCC 的内联汇编特性，用 asm 伪指令可以在程序中包含简短的汇编代码。

# 3.3 数据格式

Intel 用术语 **字 (word)** 表示 16 位数据类型，称 32 位数为 **双字（double words）**，64 位数为 **四字（quad words）**。

大多数 GCC 生成的汇编代码指令都有一个字符的后缀用于*表明操作数的大小*。

> 浮点数使用的是一组完全不同的指令和寄存器。

![C 语言数据类型在 x64 中的大小]({{ site.baseurl }}/picture/Pasted-image-20230926002724.png)

# 3.4 访问信息

一个 x64 的中央处理单元（CPU）包含一组 16 个存储 64 位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。

如图中嵌套的方框标明，指令可以对这 16 个寄存器的低位字节中存放的不同大小的数据进行操作。

在常见的程序里不同的寄存器扮演不同的角色。 其中最特别的是栈指针 `%rsp`（Register Stack Pointer），用来*指明运行时栈的结束位置*。另外 15 个寄存器的用法更灵活，少量指令会使用某些特定的寄存器。

![整数寄存器]({{ site.baseurl }}/picture/Pasted-image-20230925213934.png)

## 3.4.1 操作数指示符

大多数指令有一个或多个**操作数（operand）**，指示出执行一个操作中要*使用的源数据值*和*放置结果的目标位置*。

操作数可以分为三种类型：

- **立即数（immediate）**：表示*常数值*。
- **寄存器（register）**： 表示*某个寄存器的内容*。 $r_{a}$ 表示寄存器 $a$, $R[r_{a}]$ 表示它的值。
- **内存引用**：根据计算出来的地址（有效地址）*访问某个内存位置*。$M_{b}[Addr]$ 表示对存储在内存中从地址 $Addr$ 开始的 $b$ 个字节值的引用。为了简便通常省去下标 $b$。

![操作数格式]({{ site.baseurl }}/picture/Pasted-image-20230926095514.png)

## 3.4.2 数据传送指令

最频繁使用的指令是*将数据从一个位置复制到另一个位置*的指令。

不同的数据传送指令或者源和目的类型不同，或者执行的转换不同，或者具有副作用不同。我们把许多不同的指令划分成**指令类**，每一类中的指令执行相同的操作，*只不过操作数大小不同*。

是最简单形式的数据传送指令——**MOV 类**。这些指令把*数据从源位置复制到目的位置，不做任何变化*。

> x64 中数据传送指令的两个操作数**不能都指向内存位置**。
> x64 中任何为寄存器生成 32 位值的指令都会把该寄存器的高位部分置 0。

![简单的数据传送指令]({{ site.baseurl }}/picture/Pasted-image-20230927002233.png)

**MOVZ 类** 和 **MOVS 类** 在将较小的源值复制到较大的目的时使用，所有这些指令都把数据从（在寄存器或内存中）复制到目的寄存器：

- MOVZ 类中的指令把目的中剩余的字节填充为 0。
- MOVS 类中的指令通过符号扩展来填充，把源操作的最高位进行复制。

## 3.4.3 数据传送示例

![数据传送示例]({{ site.baseurl }}/picture/Pasted-image-20230927002152.png)

- 参数通过寄存器传递给函数。函数通过把值存储在寄存器 `%rax` 或该寄存器的某个低位部分中返回。
- C 语言中*指针*其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。
- 局部变量通常是保存在寄存器中，而不是内存中，以提高访问速度。

## 3.4.4 压入和弹出栈数据

**栈**是一种*后进先出*数据结构，可以添加或者删除值。

通过 `push` 操作把数据压入栈中，通过 `pop` 操作删除数据；它具有一个属性：*弹出的值永远是最近被压入而且仍然在栈中的值*。栈可以实现为一个数组，总是从数组的一端插入和删除元素。这一端被称为**栈顶**。在 x64 中，程序栈存放在内存中某个区域。如图所示，栈向下增长，因此栈顶元素的地址是所有栈中元素地址中最低的（栈是倒过来画的）。栈指针 `%rsp` 保存着栈顶元素的地址。

`pushq` 指令的功能是把数据压入到栈上，而 `popq` 指令是弹出数据。这些指令都只有一个操作数一一*压入的数据源 S* 或 *弹出的数据目的 D* 。

因为栈和程序代码以及其他形式的程序数据都是放在同一内存中，所以程序可以*用标准的内存寻址方法访问栈内的任意位置*。假设栈顶元素是四字，指令 `movq 8(%rsp)` 会将第二个四字从栈中复制到寄存器 `%rdx` 。

![入栈和出栈指令]({{ site.baseurl }}/picture/Pasted-image-20230927002103.png)

![栈操作说明]({{ site.baseurl }}/picture/Pasted-image-20230927001843.png)

# 3.5 算术和逻辑操作

大多数算术和逻辑操作都分成了指令类，这些指令类有各种带不同大小操作数的变种（只有 `leaq` 没有其他大小的变种）。

操作被分为四组：加载有效地址、一元操作、二元操作和移位。二元操作有两个操作数，一元在操作有一个操作数。

![整数算术操作]({{ site.baseurl }}/picture/Pasted-image-20231007093335.png)

## 3.5.1 加载有效地址

**加载有效地址**（load effective address）指令 `leaq` 实际上是 `movq` 指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它是*将有效地址写人到目的操作数*，这条指令可以*为后面的内存引用产生指针*（C 语言中*地址操作符* `&`）。

`leaq` 指令能执行加法和有限形式的乘法，在编译简单的算术表达式时是很有用处的。

![leaq 在编译出的代码中的使用]({{ site.baseurl }}/picture/Pasted-image-20231007094834.png)

## 3.5.2 一元和二元操作

第二组中的操作是**一元操作**，只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置（C 语言中*自增自减运算符*）。

第三组是**二元操作**，其中，第二个操作数既是源又是目的。其中源操作数是第一个，目的操作数是第二个，第一个操作数可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器或是内存位置（C 语言中*赋值运算符*）。

## 3.5.3 移位操作

最后一组是**移位操作**，先给出移位量，然后第二项给出的是要移位的数。可以进行算术和逻辑右移。移位量可以是一个立即数，或者放在*单字节*寄存器 `%cl` 中。原则上来说，1 个字节的移位量使得移位量的编码范围可以达到 $2^8$。x64 中，移位操作对 $w$ 位长的数据值进行操作时，移位量是由 `%cl` 寄存器的低 $m$ 位决定的， 这里 $2^m=w$。高位会被忽略（C 语言中*移位运算符*）。 

- 左移指令有两个名字：`SAL` 和 `SHL` 两者的效果是一样的，都是将右边填上 0。
- 右移指令不同，`SAR` 执行算术移位（填上符号位），而 `SHR` 执行逻辑移位（填上 0）。移位操作的目的操作数可以是一个寄存器或是一个内存位置。

## 3.5.4 讨论

大多数指令既可以用于无符号运算，也可以用于补码运算。

只有右移操作要求区分有符号和无符号数。这个特性使得补码运算成为实现有符号整数运算的一种比较好的方法的原因之一。

![算术运算函数示例]({{ site.baseurl }}/picture/Pasted-image-20231007101558.png)

## 3.5.5 特殊的算术操作

两个 64 位有符号或无符号整数相乘得到的乘积需要 128 位来表示。x64 指令集对 128 位（16 字节）数的操作*提供有限的支持*。lntel 把 16 字节的数称为**八字（oct word）**。如图描述的是支持产生两个 64 位数字的全 128 位乘积以及整数除法的指令。

![特殊的算术操作]({{ site.baseurl }}/picture/Pasted-image-20231007102016.png)

# 3.6 控制

到目前为止，我们只考虑了直线代码的行为，也就是指令一条接着一条顺序地执行。机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。

与数据相关的控制流是实现有条件行为的更一般和更常见的方法。用 `jump` 指令可以改变一组机器代码指令的执行顺序，`jump` 指令指定控制应该被传递到程序的某个其他部分，可能是依赖于某个测试的结果。编译器必须产生构建在这种低级机制基础之上的指令序列，来实现 C 语言的控制结构。

## 3.6.1 条件码

除了整数寄存器，CPU 还维护着一组单个位的**条件码（code）寄存器**，它们*描述了最近的算术或逻辑操作的属性*。可以检测这些寄存器来执行条件分支指令。最常用的条件码有：

- `CF`：**进位标志**。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。
- `ZF`：**零标志**。最近的操作得出的结果为 0。
- `SF`：**符号标志**。最近的操作得到的结果为负数。
- `OF`：**溢出标志**。最近的操作导致一个补码溢出——正溢出或负溢出 。

`leaq` 指令不改变任何条件码，因它是用进行地址计的。除此之外，所有的算术和逻辑操作都会设置条件码。

还有两类指令，它们**只设置条件码而不改变任何其他寄存器**：

- `CMP` 指令*根据两个操作数之差来设置条件码*。除了只设置条件码而不更新目的寄存器之外，`CMP` 指令与 `SUB` 指令的行为是一样的。如果两个操作数相等，这些指令会将零标志设置为 1，而其他的标志可以用来确定两个操作数之间的大小关系。
- `TEST` 指令的行为与 `AND` 指令一样，除了它们只设置条件码而不改变目的寄存器的值。典型的用法是，两个操作数是一样的（用来检查是负数、零，还是正数），或其中的一个操作数是一个掩码，用来指示哪些位应该被测试。

![比较和测试指令]({{ site.baseurl }}/picture/Pasted-image-20231007144611.png)

## 3.6.2 访问条件码

条件码通常不会直接读取，常用的使用方法有三种：

- 可以根据条件码的某种组合，将一个字节设置为 0 或者 1。
- 可以条件跳转到程序的某个其他的部分。
- 可以有条件地传送数据。

对于第一种情况，我们将这一整类指令称为 `SET` 指令；它们之间的区别就在于它们*考虑的条件码的组合是什么*，这些指令名字的不同后缀指明了它们所考虑的条件码的组合（`setl` -> `set less`、`setb` -> `set below`）。

一条 `SET` 指令的目的操作数是低位单字节寄存器元素之一，或是一个字节的内存位置，指令会将这个字节设置成 0 或者 1。为了得到一个 32 位或 64 位结果，我们必须对高位清零。 

各个 `SET` 命令的描述都适用的情况是：执行比较指令，根据计算 $t=a-b$ 设置条件码。更具体地说，假设 $a、b、t$ 分别是变量 $a、b、t$ 的补码形式表示的整数，因此 $t=a-{ }_w^{t} b$，这里 $w$ 取决于 $a$ 和 $b$ 的大小。

对于无符号比较的测试，现在 $a、b$ 是变量 $a、b$ 的无符号形式表示的整数。在执行计算 $t=a-b$ 中，当 $a-b<0$ 时，`CMP` 指令会设置进位标志，因而无符号比较使用的是进位标志和零标志的组合。

![SET 指令]({{ site.baseurl }}/picture/Pasted-image-20231007145442.png)

一个计算 C 语言表达式 a < b 的典型指令序列如下所示，这里 a 和 b 都是 long 类型：

> `movzbl` 指令不仅会把 `%eax` 的高 3 个字节清零，还会把整个寄存器 `%rax` 的高 4 个字节都清零 。

![a < b]({{ site.baseurl }}/picture/Pasted-image-20231007145857.png)

某些底层的机器指令可能有多个名字，我们称之为**同义名（synonym）**。比如说`setg`（表示*设置大于*）和`setnle`（表示*设置不小于等于*）指的就是同一条机器指令。编译器和反汇编器会随意决定使用哪个名字。

注意到机器代码如何*区分有符号和无符号值*是很重要的。同 C 语言不同，大多数情况下机器代码对于有符号和无符号两种情况都使用一样的指令，这是因为许多算术运算对无符号和补码算术都有一样的位级行为。有些情况需要用不同的指令来处理有符号和无符号操作，如使用不同版本的右移、除法和乘法指令，以及不同的条件码组合 。

## 3.6.3 跳转指令

**跳转（jump）指令**会导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个**标号**（label）指明。

指令 `jmp .L1` 会导致程序跳过 `movq` 指令，而从 `popq` 指令开始继续执行。在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标（目的指令的地址）编码为跳转指令的一部分。

![jump 指令示例]({{ site.baseurl }}/picture/Pasted-image-20231007153300.png)

`jmp` 指令是**无条件跳转**。它可以是**直接跳转**，即跳转目标是作为指令的一部分编码的；也可以是**间接跳转**，即跳转目标是从寄存器或内存位置中读出的。汇编语言中，**直接跳转**是给出一个标号作为跳转目标的，如标号 `.L1`。**间接跳转**的写法是 `*`，后面跟一个操作数指示符，如 `jmp *%rax`。

表中所示的其他跳转指令都是**有条件跳转**一一它们根据条件码的某种组合，或者跳转，或者继续执行代码序列中下一条指令。这些指令的名字和跳转条件与 `SET` 指令的名字和设置条件是相匹配的。同 `SET` 指令一样，一些底层的机器指令有多个名字。条件跳转只能是直接跳转。

![jump 指令]({{ site.baseurl }}/picture/Pasted-image-20231007151708.png)

## 3.6.4 跳转指令的编码

在汇编代码中，跳转目标用符号标号书写。汇编器，以及链接器，会产生跳转目标的适当编码。跳转指令有几种不同的编码，但是最常用都是 **PC 相对的（PC-relative）**，它们会*将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差*作为编码。这些地址偏移量可以编码为 1、2、4 个字节。第二种编码方法是给出**绝对地址**，用 4 个字节直接指定目标。汇编器和链接器会选择适当的跳转目的编码。

当执行 PC 相对寻址时，程序计数器（PC）的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。

通过使用与 PC 相对的跳转目标编码，指令编码可以很简洁（只需要 2 个字节），而且目标代码可以不做改变就移到内存中不同的位置。

> .o 反汇编代码产生的注释中，第 2 行中跳转指令的跳转目标指明为 0x8，第 5 行中跳转指令的跳转目标是 0x5（反汇编器以十六进制格式给出所有的数字）。不过，观察指令的字节编码，会看到第一条跳转指令的目标编码（在第二个字节中）为 0x03。把它加上 0x5，也就是下一条指令的地址，就得到跳转目标地址 0x8，也就是第 4 行指令的地址。

![汇编代码]({{ site.baseurl }}/picture/Pasted-image-20231007154456.png)

![.o 反汇编代码]({{ site.baseurl }}/picture/Pasted-image-20231007154415.png)

![链接后的反汇编代码]({{ site.baseurl }}/picture/Pasted-image-20231007154359.png)

## 3.6.5 用条件控制来实现条件分支

将条件表达式和语句从 C 语言翻译成机器代码，最常用的方式是*结合有条件和无条件跳转*。

C 语言中的 `if-else` 语句的通用形式模板如下：

```c
if(test-expr)
	then-statement
else
	else-statement
```

对于这种通用形式，汇编实现通常会使用下面这种形式，汇编器会为 `then-statement` 和 `else-statement` 产生各自的代码块。它会插人条件和无条件分支，以保证能执行正确的代码块。

```c
	t = test-expr；
	if(!t)
		goto false;
	then-statement
	goto done;
false:
	else-statement
done:
```

> 使用 goto 语句通常认为是一种不好的编程风格，因为它会使代码非常难以阅读和调试。`if goto` 对应汇编中的有条件跳转，而 `goto` 对应无条件跳转。

![条件语句的编译]({{ site.baseurl }}/picture/Pasted-image-20231011163457.png)

## 3.6.6 用条件传送来实现条件分支

实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿一条执行路径执行，而当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代处理器上，它*可能会非常低效*。

一种替代的策略是使用**数据的条件转移**。这种方法*计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个*。只有在一些受限制的情况中，这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现它，条件传送指令更符合现代处理器的性能特性。

### 性能分析

- 现代处理器通过使用**流水线**（pipelining）来获得高性能，在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分，这种方法通过重叠连续指令的步骤来获得高性能。要做到这一点，要求能够事先确定要执行的指令序列，这样才能保持流水线中充满了待执行的指令。当机器遇到条件跳转（分支）时，只有当分支条件求值完成之后，才能决定分支往哪边走。处理器采用非常精密的分支预测逻辑来猜测每条跳转指令是否会执行，只要它的猜测还比较可靠（现代微处理器设计试图达 90% 以上的成功率），指令流水线中就会充满着指令。另一方面，错误预测一个跳转，要求处理器丢掉它为该跳转指令后所有指令己做的工作，然后再开始用从正确位置处起始的指令去填充流水线。这样一个错误预测会招致很严重的惩罚，浪费大约 15~30 个时钟周期，导致程序性能严重下降。
- 在一个典型的应用中，`x < y` 的结果非常地不可预测，因此即使是最精密的分支预测硬件也只能有大约 50% 的概率猜对。此外，两个代码序列中的计算执行都只需要一个时钟周期。因此，分支预测错误处罚主导着这个函数的性能。
- 另一方面，无论测试的数据是什么，编译出来使用条件传送的代码所需的时间都是大约 8 个时钟周期。控制流不依赖于数据，这使得处理器更容易保持流水线是满的。

![使用条件赋值的条件语句编译]({{ site.baseurl }}/picture/Pasted-image-20231007162552.png)

### 条件传送指令

条件传送指令中每条指令都有两个操作数：源寄存器或者内存地址 `S`，和目的寄存器 `R`。与不同的 `SET` 和跳转指令一样，这些指令的*结果取决于条件码的值*。源值可以从内存或者源寄存器中读取，但是只有在指定的条件满足时，才会被复制到目的寄存器中。

源和目的的值可以是 16 位、32 位或 64 位长。不支持单字节的条件传送。无条件指令的操作数的长度显式地编码在指令名中，汇编器可以从目标寄存器的名字推断出条件传送指令的操作数长度，所以对所有的操作数长度，都可以使用同一个的指令名字。

![条件传送指令]({{ site.baseurl }}/picture/Pasted-image-20231007161917.png)

同条件跳转不同，处理器无需预测测试的结果就可以执行条件传送。处理器只是读源值（可能是从内存中），检查条件码，然后要么更新目的寄存器，要么保持不变。

### 条件传送示例

`v = test-expr ? then-expr : else-expr;`

用条件控制转移的标准方法来编译这个表达式会得到如下形式：

```c
	if (!test-expr)
		goto false;
	v = then-expr;
	goto done;
false:
	v = else-expr;
done:
```

- 基于条件传送的代码，会对 `then-expr` 和` else-expr` 都求值，最终值的选择基于对 `test-expr` 的求值，如果这两个表达式中的任意一个可能产生错误条件或者副作用，就会导致非法的行为（如对空指针解引用）。
- 使用条件传送也不总是会提高代码的效率。如果 `then-expr` 或 `else-expr` 的求值需要大量的计算，那么当相对应的条件不满足时，这些工作就白费了。编译器必须考虑浪费的计算和由于分支预测错所造成的性能处罚之间的相对性能。

```c
v = then-expr;
ve = else-expr;
t = test-expr;
if (!t) v = ve;
```

## 3.6.7 循环

C 语言提供了多种循环结构，汇编中没有相应的指令存在，可以用条件测试和跳转组合起来实现循环的效果。GCC 和其他汇编器产生的循环代码主要基于两种基本的循环模式。

### do-whiie 循环

do-while 语句的通用形式如下：

```c
do
	body-statement
	while(test-expr);
```

这种通用形式可以被翻译成如下所示的条件和 goto 语句：

```c
loop:
	body-statement
	t = test-expr;
	if(t)
		goto loop;
```

![do-while 循环示例：阶乘程序]({{ site.baseurl }}/picture/Pasted-image-20231007171029.png)

> **逆向工程**：理解产生的汇编代码与原始源代码之间的关系，关键是*找到程序值和寄存器之间的映射关系*。C 语言编译器常常会重组计算，因此有些代码中的变量在机器代码中没有对应的值；而有时，机器代码中又会引入源代码中不存在的新值。此外，编译器还常常试图将多个程序值映射到一个寄存器上，来最小化寄存器的使用率。

### while 循环

while 语句的通用形式如下：

```c
while(test-expr)
	body-statement
```

有很多种方法将 while 循环翻译成机器代码，GCC 在代码生成中使用其中的两种方法。这两种方法使用同样的循环结构，不过它们实现初始测试的方法不同。

#### 跳转到中间（jump to middle）

**跳转到中间**（jump to middle）执行一个无条件跳转跳到循环结尾处的测试，以此来执行初始的测试：

```c
	goto test;
loop:
	body-statement
test:
	t = test-expr;
	if(t)
		goto loop;
```

![使用跳转到中间翻译方法的阶乘算法]({{ site.baseurl }}/picture/Pasted-image-20231007172338.png)

#### guarded-do

**guarded-do** 首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为 `do- while` 循环。当使用较高优化等级编译时，GCC 会采用这种策略，利用这种实现策略，编译器常常可以优化初始的测试，例如认为测试条件总是满足。

```c
t = test-expr;
if(!t)
	goto done;
loop:
	body-statement
	t = test-expr;
	if(t)
		goto loop;
done:
```

![GCC 使用命令行选项 -O1 时的编译]({{ site.baseurl }}/picture/Pasted-image-20231007173020.png)

![使用 guarded-do 翻译方法的阶乘算法]({{ site.baseurl }}/picture/Pasted-image-20231007173213.png)

### for 循环

for 循环的通用形式如下：

```c
for(init-expr; test-expr; update-expr)
	body-statement
```

这样一个循环的行为与下面这段使用 while 循环的代码的行为一样：

```c
init-expr;
while(test-expr){
	body-statement
	update-expr;
}
```

GCC 为 for 循环产生的代码是 while 循环的两种翻译之一，这取决于优化的等级。

## 3.6.8 switch 语句

**switch（开关）语句**可以根据一个整数索引值进行*多重分支（multiway branching）*。在处理具有多种可能结果的测试时，这种语句特别有用。它们不仅提高了代码的可读性，而且通过使用**跳转表**（jump table）这种数据结构使得实现更加高效。跳转表是一个数组，**表项**是一个代码段的地址，这个代码段实现当开关索引值等于时程序应该采取的动作。程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。

和使用一组很长的 `if else` 语句相比，使用跳转表的优点是*执行开关语句的时间与开关情况的数量无关*。GCC 根据*开关情况的数量和开关情况值的稀疏程度*来翻译开关语句。当开关情况数量比较多（例如 4 个以上），并且值的范围跨度比较小时，就会使用跳转表。

- GCC 扩展 **&&**：创建一个指向代码位置的指针
- GCC 扩展**计算 goto**：`goto *jt[index]` `jmp *.L4(,%rsi,8)`是一个间接跳转，操作数指定一个内存位置，索引由寄存器给出；
- 跳转表对重复情况的处理就是简单地对表项用同样的代码标号，而对于缺失的情况的处理就是对表项使用默认情况的标号。
- 在叫做 `.rodata`（只读数据， Read-Only Data）的目标代码文件的段中，有一组 7 个四字，每个字的值都是与指定的汇编代码标号相关联的指令地址。标号 `.L4` 标记出这个分配地址的起始。与这个标号相对应的地址会作为间接跳转的基地址。

![switch 语句示例以及翻译到扩展的 C 语言]({{ site.baseurl }}/picture/Pasted-image-20231007182045.png)

![switch 语句示例的汇编代码]({{ site.baseurl }}/picture/Pasted-image-20231007182105.png)

![跳转表]({{ site.baseurl }}/picture/Pasted-image-20231007191153.png)

# 3.7 过程

**过程**是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后，可以在程序中不同的地方调用这个函数。

设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是哪些值，过程会对程序状态产生什么样的影响。

不同编程语言中，过程的形式多样：*函数（function） 、方法（method） 、子例程（subroutine） 、处理函数（handler）* 等等，但是它们有一些共有的特性。

要提供对过程的机器级支持，必须要处理许多不同的属性。为了讨论方便，假设过程 P 调用过程 Q，Q 执行后返回到 P。这些动作包括下面一个或多个机制：

- **传递控制**：在进入过程 Q 的时候，程序计数器必须被设置为 Q 的代码的起始地址，然后在返回时，要把程序计数器设置为 P 中调用 Q 后面那条指令的地址。
- **传递数据**：P 必须能够向 Q 提供一个或多个参数，Q 必须能够向 P 返回一个值。
- **分配和释放内存**：在开始时，Q 可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。

x64 的过程实现包括一组特殊的指令和一些对机器资源（例如寄存器和程序内存）使用的约定规则。出于性能考虑，它遵循了被认为是最低要求策略的方法，只实现上述机制中每个过程所必需的那些。

## 3.7.1 运行时栈

C 语言过程调用机制的一个关键特性在于使用了栈数据结构提供的后进先出的内存管理原则。

在过程 P 调用过程 Q 的例子中：

- 当 Q 运行时，P 以及所有在向上追溯到  P 的调用链中的过程，都是暂时被挂起的。
- 当 Q 运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。
- 当 Q 返回时，任何它所分配的局部存储空间都可以被释放。

因此，程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息：

- 当 P 调用 Q 时，控制和数据信息添加到栈尾。
- 当 P 返回时，这些信息会释放掉。

x64 的栈向低地址方向增长，而栈指针 `%rsp` 指向栈顶元素。可以用 `pushq` 和 `popq` 指令将数据存入栈中或是从栈中取出。

当 x64 过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间，这个部分称为过程的**栈帧（stack fram）**。

- 当前正在执行的过程的帧总是在栈顶。
- 当过程 P 调用过程 Q 时，把返回地址压入栈中，指明 Q 返回时，要从 P 程序的哪个位执行。
- Q 的代码会扩展当前栈的边界，分配它的栈帧所需的空间。
- 大多数过程的栈帧都是定长的，在过程的开始就分配好了，但是有些过程需要变长的帧。

![通用的栈帧结构]({{ site.baseurl }}/picture/Pasted-image-20230925225805.png)

## 3.7.2 转移控制

将控制从函数 P 转移到函数 Q 只要简单地把程序计数器（PC）设置为 Q 的代码的起始位置。

稍后从 Q 返回的时候，处理器必须记录好它需要继续 P 的执行的代码位置。x64 中，这个信息是用指令 `call Q` 调用过程 Q 来记录的。该指令会把地址 A 压入栈中，并将 PC 设置为 Q 的起始地址。

压入的地址 A 被称为返回地址，是紧跟在 `call` 指令后面的那条指令的地址。对应的指令 ret 从栈中弹出地址 A, 并把 PC 设置 A。

`call` 指令有一个目标，即*指明被调用过程起始的指令地址*。调用可以是直接的，也可以是间接的。

这种把返回地址压入栈的简单的机制能够让函数在稍后返回到程序中正确的点。C 语言（以及大多数程序语言）标准的调用／返回机制刚好与栈提供的后进先出的内存管理方法吻合。

![]({{ site.baseurl }}/picture/Pasted-image-20231007201428.png)

![]({{ site.baseurl }}/picture/Pasted-image-20231010220438.png)
![]({{ site.baseurl }}/picture/Pasted-image-20231010220447.png)

![cll 和 ret 函数的说明]({{ site.baseurl }}/picture/Pasted-image-20231007201457.png)

## 3.7.3 数据传送

当调用一个过程时，除了要把控制传递给它并在过程返回时再传递回来之外，过程调用还可能包括*把数据作为参数传递*，而从过程返回还有可能包括*返回一个值*。

x64 中，大部分过程间的数据传送是通过寄存器实现的。过程 P 调用过程 Q 时，P 的代码必须首先把参数复制到适当的寄存器中。

x64 中，可以通过寄存器最多传递 6 个整型（例如整数和指针）参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决千要传递的数据类型的大小。

如果一个函数有大于 6 个整型参数，超出 6 个的部分就要通过栈来传递。

通过栈传递参数时，所有的数据大小都向 8 的倍数对齐。参数到位以后，程序就可以执行 `call` 指令将控制转移到过程 Q 了。过程 Q 可以通过寄存器访问参数，有必要的话也可以通过栈访问。

![有多个不同类型参数的函数示例]({{ site.baseurl }}/picture/Pasted-image-20231010221352.png)

![函数 proc 的栈帧结构]({{ site.baseurl }}/picture/Pasted-image-20231010221433.png)

## 3.7.3 栈上的局部存储

有些时候，局部数据必须存放在内存中，常见的情况包括：

- 寄存器不足够存放所有的本地数据。
- 对一个局部变量使用地址运算符 `＆`，因此必须能够为它产生一个地址。
- 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。

一般来说，过程通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标号为*局部变量*。

![]({{ site.baseurl }}/picture/Pasted-image-20231010222031.png)

![]({{ site.baseurl }}/picture/Pasted-image-20231010222008.png)

![]({{ site.baseurl }}/picture/Pasted-image-20231010221937.png)

## 3.7.5 寄存器中的局部存储空间

**寄存器组是唯一被所有过程共享的资源**。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此，x64 用了一组统一的寄存器使用惯例，所有的过程（包括程序库）都必须遵循：

- 寄存器 `%rbx %rbp %r12~%r15` 被划分为**被调用者保存寄存器**。当过程  P 调用过程 Q 时，必须保存这些寄存器的值，保证它们的值在 Q 返回到 P 时与被调用时是一样的（根本不改变或压入栈中）。
- 所有其他的寄存器，除了栈指针 `%rsp`，都分类为**调用者保存寄存器**。这就意味着任何函数都能修改它们，在调用之前首先保存好这个数据是调用者的责任。

![]({{ site.baseurl }}/picture/Pasted-image-20231010222901.png)

## 3.7.6 递归过程

递归调用一个函数本身与调用其他函数是一样的。栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息存储空间。如果需要，它还可以提供局部变量的存储。栈分配和释放的规则很自然就与函数调用—返回的顺序匹配。

![]({{ site.baseurl }}/picture/Pasted-image-20231010223218.png)

# 3.8 数组分配和访问

C 语言中的数组是一种将标量数据聚集成更大数据类型的方式。其实现数组的方式 非常简单，因此很容易翻译成机器代码。C 语言的一个不同寻常的特点是可以产生指向数组中元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译成地址计算。

优化编译器非常善于简化数组索引所使用的地址计算。不过这使得代码和它到机器代码的翻译之间的对应关系有些难以理解。

## 3.8.1 基本原则

对于数据类型 $T$ 和整型常数 $N$，声明如下：

`T A[N];`

起始位置表示为 $x_{A}$，这个声明有两个效果：

- 它在内存中分配 $L*N$ 字节的连续区域，这里 $L$ 是数据类型的大小。
- 它引入了标识符 $A$, 可以用 $A$ 作为指向数组开头的指针，这个指针的值就是 $x_{A}$。可以用 $0-{N-1}$ 的整数索引来访问该数数组元素。数组元素会被存放在地址为$x_{A}+L*i$ 的地方。

## 3.8.2 指针运算

假设整型数组 E 的起始地址和整数索引 $i$ 分别存放在寄存器 `%rdx %rcx` 中。结果存放在寄存器 `%eax`（如果是数据）或寄存器 `%rax`（如果是指针）中：

- 返回数组值的操作类型为 `int`，因此涉及 4 字节操作（如 `movl`）和寄存器（如 `%eax`) 。
- 返回指针的操作类型为 `int *`，因此涉及 8 字节操作（如 `leaq`）和寄存器（如 `%rax`) 。

![]({{ site.baseurl }}/picture/Pasted-image-20231010230640.png)

## 3.8.3 嵌套的数组

当我们创建数组的数组时，数组分配和引用的一般原则也是成立的。

数组元素在内存中*按照行优先的顺序排列*。

通常来说，对于一个声明如下的数组：$T\quad D[R][C]$，它的数组元素 $D[i][j]$ 的内存地址为：$\&D[i][j]=x_{D}+L\left(C \cdot i+j\right)$。

![按照行优先顺序存储的数组元素]({{ site.baseurl }}/picture/Pasted-image-20231010233444.png)

## 3.8.4 定长数组

C 语言编译器能够优化定长多维数组上的操作代码（去掉了整数索引 $j$，并把所有的数组引用都转换成了指针间接引用）。

![]({{ site.baseurl }}/picture/Pasted-image-20231010234300.png)

![]({{ site.baseurl }}/picture/Pasted-image-20231010234318.png)

## 3.8.5 变长数组

历史上，C 语言只支持大小在编译时就能确定的多维数组。程序员需要变长数组时不得不用 `malloc calloc` 这样的函数为这些数组分配存储空间，而且不得不显式地编码，用行优先索引将多维数组映射到一维数组。 ISO C99 引入了一种功能，允许数组的维度是表达式，在数组被分配的时候才计算出来。

动态的版本必须用乘法指令对 $i$ 伸缩 $n$ 倍，而不能用一系列的移位和加法。在一些处理器中，乘法会招致严重的性能处罚，但是在这种情况中无可避免。如果允许使用优化，GCC 能够识别出程序访问多维数组的元素的步长。然后生成的代码会避免直接应用等式导致的乘法。

![]({{ site.baseurl }}/picture/Pasted-image-20231011170528.png)

# 3.9 异质的数据结构

C 语言提供了两种将不同类型的对象组合到一起创建数据类型的机制：结构（structure），用关键字 struct 来声明，将多个对象集合到一个单位中；联合 （union），用关键 union 来声明，允许用几种不同的类型来引用一个对象。

## 3.9.1 结构

C 语言的 struct 声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中。用名字来引用结构的各个组成部分。结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段（field）的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。

```c
struct rec {
	int i;
	int j;
	int a[2];
	int *p;
};
```

![]({{ site.baseurl }}/picture/Pasted-image-20231010234949.png)

## 3.9.2 联合

联合提供了一种方式，能够规避 C 语言的类型系统，允许以多种类型来引用一个对 象。联合声明的语法与结构的语法一样，只不过语义相差比较大。它们是用不同的字段来引用相同的内存块。

联合十能引起一些讨厌的错误，因为它们绕过了 C 语言类型系统提供的安全措施。

- 我们事先知道对一个数据结构中的两个不同字段的使用是互斥的，那么将这两个字段声明为联合的一部分会减小分配空间的总量。
- 联合还可以用来访问不同数据类型的位模式。

```c
typedef enum { N_LEAF, N_INTERNAL } nodetype_t;

struct node_t {
	nodetype_t type;
	union {
		struct {
			struct node_t *left;
			struct node_t *right;
		} internal;
		double data[2];
	} info;
};

unsigned long doub1e2bits(double d) {
	union {
		double d;
		unsigned long;
	} temp；
	temp.d = d;
	return temp.u;
};
```

## 3.9.2 数据对齐

许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值 K（通常是 2、4、8）的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计的倍数。假设一个处理器总是从内存中取 8 个字节，则地址必须为 8 的倍数。如果我们能保证将所有的 double 类型数据的地址对齐成 8 的倍数，那么就可以用一个内存操作来读或者写值了。否则，我们可能需要执行两次内存访问，因为对象可能被分放在两个字节内存块中。

无论数据是否对齐，x64 硬件都能正确工作。不过，Intel 还是建议要对齐数据以提高内存系统的性能。对齐原则是任何 K 字节的基本对象的地址必须是 K 的倍数。可以看到这条原则会得到如下对齐：

![]({{ site.baseurl }}/picture/Pasted-image-20231011180235.png)

编译器在汇编代码中放人命令，指明全局数据所需的对齐（`.align 8`），这就保证了它后面的数据的起始地址是 8 的倍数。

对于包含结构的代码，编译器可能需要在字段的分配中插人间隙，以保证每个结构元素都满足它的对齐要求。而结构本身对它的起始地址也有一些对齐要求。另外，编译器结构的末尾可能需要一些填充，这样结构数组中的每个元素都会满足它的对齐要求。

假设编译器用最小的 9 字节分配，它是不可能满足字段 `i`（偏移为 0）和 `j`（偏移为 5）的 4 字节对齐要求的。取而代之地，编译器在字段 `c` 和 `j` 之间插人一个 3 字节的间隙，此外，编译器必须保证任何 `struct S1 *` 类型的指针 `p` 都满足 4 字节对齐，这就保证了 `p->i`（$x_{P}$）和 `p->j`（$x_{P}+8$）都满足它们的 4 字节对齐要求：

```c
struct Sl {
	int i;
	char c;
	int j;
};
```

![偏移内容]({{ site.baseurl }}/picture/Pasted-image-20231011182138.png)

![偏移内容]({{ site.baseurl }}/picture/Pasted-image-20231011182151.png)

# 3.10 在机器级程序中将控制与数据结合起来

## 3.10.1 理解指针

一些指针和它们映射到机器代码的关键原则：

- 每个指针都对应一个类型。这个类型表明该指针指向的是哪一类对象。指针类型不是机器代码中的一部分；它们是 C 语言提供的一种抽象，帮助程序员避免寻址错误。
- 每个指针都有一个值。这个值是某个指定类型的对象的地址。
- 指针用 `&` 运算符创建。这个运算符可以应用到任何 lvalue 类（左值）的表达式上，因为 `leaq` 指令是设计用来计算内存引用的地址的，`＆` 运算符的机器代码实现常常用这条指令来计算表达式的值。
- `*` 操作符用于间接引用指针。其结果是一个值，它的类型与该指针的类型一致。间接引用是用内存引用来实现的，要么是存储到一个指定的地址，要么是从指定的地址读取。
- 数组与指针紧密联系。
- 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。强制类型转换的一个效果是改变指针运算的伸缩。
- 指针也可以指向函数。这提供了一个很强大的存储和向代码传递引用的功能，这些引用可以被程序的某个其他部分调用。函数指针的值是该函数机器代码表示中第一条指令的地址。

## 3.10.2 应用：使用 GDB 调试器

通常的方法是在程序中感兴趣的地方附近设置断点。程序在执行过程中遇到一个断点时，程序会停下来，并将控制返回给用户。在断点处，我们能够以各种方式查看各个寄存器和内存位置。我们也可以单步跟踪程序，一次只执行几条指令，或是前进到下一个断点。

![GDB 命令示例]({{ site.baseurl }}/picture/Pasted-image-20231007202226.png)

## 3.10.3 内存越界引用和缓冲区溢出

C 对于数组引用不进行任何边界检查，而且局部变量和状态信息都存放在栈中。对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破的状态，试图重新加载寄存器或执行 `ret` 指令时，就会出现很严重的错误。

一种特别常见的状态破坏称为**缓冲区溢出（buffer overflow）**。通常，在栈中分配某个字符数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。

`gets` 的问题是它没有办法确定是否为保存整个字符串分配了足够的空间。使用 `gets` 或其他任何能导致存储溢出的函数，都是不好的编程习惯。

超过 23 个字符后，返回指针的值以及更多可能的保存状态会被破坏。如果存储的返回地址的值被破坏了，那么 `ret` 指令会*导致程序跳转到完全意想不到的位置*。

**通过计算机网络攻击系统安全**——缓冲区溢出，通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为**攻击代码（exploit code）**, 另外，还有一些字节会用一个指向攻击代码的指针覆盖返回地址，执行 `ret` 指令的效果就是跳转到攻击代码：

- 在一种攻击形式中，攻击代码会使用系统调用启动一个 shell 程序，给攻击者提供一组操作系统函数。
- 在另一种攻击形式中，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行 `ret` 指令，表面上正常返回到调用者。

![缓冲区溢出示例]({{ site.baseurl }}/picture/Pasted-image-20231011203821.png)

![缓冲区溢出示例]({{ site.baseurl }}/picture/Pasted-image-20231011203845.png)

![echo 函数的栈组织]({{ site.baseurl }}/picture/Pasted-image-20231007202301.png)

## 3.10.4 对抗缓冲区溢出攻击

### 栈随机化

为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的部分。产生这个指针需要知道这个字符串放置的栈地址。过去，程序的栈地址非常容易预测。对于所有运行同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相当固定的。因此，许多系统都容易受到同一种病毒的攻击，这种现象常被称作**安全单一化（security monoculture）**。

栈随机化的思想使得栈的位置在程序每次运行时都有变化。实现的方式是：程序开始时，在栈上分配 0~n 字节之间的随机大小的空间，程序不使用这段空间。

Linux 系统中，栈随机化已经变成了标准行为。这类技术称为**地址空间布局随机化 (Address-Space Layout Randomization，ASLR）**。采用 ASLR, 每次运行时程序的不同部分都会被加载到内存的不同区域，这就意味着在一台机器上运行一个程序，与在其他机器上运行同样的程序，它们的地址映射大相径庭。

一个执著的攻击者可以反复地用不同的地址进行攻击克服随机化。一种常见的把戏就是在实际的攻击代码前插入很长一段的 nop 指令。执行这种指令除了对程序计数器加一，使之指向下一条指令之外，没有任何的效果。只要攻击者能够猜中这段序列中的某个地址，程序就会经过这个序列，到达攻击代码。这个序列常用的术语是**空操作雪橇（nop sled）**，意思是程序会*滑过*这个序列。如果我们建立一个 256 个字节的 nop sled，那么枚举 $2^{15}$ 个起始地址，就能破解 $n=2^{23}$ 的随机化，这对于一个顽固的攻击者来说，是完全可行的。对 64 位的情况，要尝试枚举 $2^24$ 就有点儿令人畏惧了。

栈随机化和其他一些 ASLR 技术能够增加成功攻击系统的难度，因而大大降低了病毒或者蠕虫的传播速度，但是也不能提供完全的安全保障。

### 栈破坏检测

在 C 语言中，没有可靠的方法来防止对数组的越界写。但是，我们能够在发生了越界写的时候，在造成任何有害结果之前，尝试检测到它。

最近的 GCC 版本在产生的代码中加入了一种**栈保护者（stack protector）机制**，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的**金丝雀（canary）**，其是在程序每次运行时随机产生的，因此，攻击者没有简单的办法能够知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了。如果是的，那么程序异常终止。

栈保护很好地防止了缓冲区溢出攻击破坏存储在程序栈上的状态。它只会带来很小的性能损失，特别是因为 GCC 只在函数中有局部 char 类型缓冲区的时候才插入这样的代码（使用命令行选项 `-fno-stack-protector` 阻止）。

![echo 函数具有栈保护的栈组织]({{ site.baseurl }}/picture/Pasted-image-20231011210814.png)

### 限制可执行代码区域

限制哪些内存区域能够存放可执行代码：在典型的程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的。其他部分可以被限制为只允许读和写。

硬件支持多种形式的内存保护，能够指明用户程序和操作系统内核所允许的访问形式。许多系统允许控制三种访问形式：读（从内存读数据）、写（存储数据到内存）和执行（将内存的内容看作机器级代码）。

## 3.10.5 支持变长栈帧

是有些函数，需要的局部存储是变长的。当函数调用 `alloca` 时就会发生这种情况。`alloca` 可以在栈上分配任意字节数量的存储。当代码声明一个局部变长数组时，也会发生这种情况。

为了管理变长栈帧，x64 代码使用寄存器 `%rbp` 作为**帧指针（frame pointer）**（有时称为**基指针（base pointer）**，这也是 `%rbp` bp 两个字母的由来）。当使用帧指针时，栈帧的组织结构与图中函数 `vframe` 的情况一样。代码必须把 `%rbp` 之前的值保存到栈中，因为它是一个被调用者保存寄存器。 然后在函数的整个执行过程中，都使得 `%rbp` 指向那个时刻栈的位置，然后用固定长度的局部变量相对于 `%rbp` 的偏移量来引用它们。

在较早版本的 x86 代码中，每个函数调用都使用了帧指针。而现在，只在栈帧长可变的情况下才使用。

![需要使用帧指针的函数]({{ site.baseurl }}/picture/Pasted-image-20231011211908.png)

![]({{ site.baseurl }}/picture/Pasted-image-20231007202545.png)

# 3.11 浮点代码

处理器的浮点体系结构包括多个方面，会影响对浮点数据操作的程序如何被映射到机器上：

- 如何存储和访问浮点数值通常是通过某种寄存器方式来完成。
- 对浮点数据操作的指令。
- 向函数传递浮点数参数和从函数返回浮点数结果的规则。
- 函数调用过程中保存寄存器的规则。

Intel AMD 都引入了持续数代的媒体（media）指令，支持图形和图像处理。这些指令本意是允许多个操作以并行模式执行，称为**单指令多数据**（SIMD）。在这种模式中，对多个不同的数据并行执行同一个操作。近年来，这些扩展有了长足的发展，从 MMX 到 **SSE（Streaming SIMD Extension，流式 SIMD 扩展）**，以及最新的 **AVX（Advanced Vector Extension，高级向量扩展）**。每个扩展都是管理寄存器组中的数据，这些寄存器组在 MMX 中称 "MM" 寄存器（64 位）， SSE 中称为 "XMM" 寄存器（128 位），而在 AVX 中称为 "YMM" 寄存器（256 位）。

2000年，媒体指令开始包括那些对标量浮点数据进行操作的指令，使用 XMM 或 YMM 寄存器的低 32 位或 64 位中的单个值。x64 浮点数是基于 SSE 或 AVX 的，包括传递过程参数和返回值的规则。

我们的讲述基于 AVX2（2013年），当给定命令行参数 `-mavx2` 时，GCC 会生成 AVX2 代码。

AVX 浮点体系结构允许数据存储在 16 个 YMM 寄存器中，当对标量数据操作时，这些寄存器只保存浮点数，而且只使用低 32 位（float）或 64 位（double）。汇编代码用寄存器的 SSE XMM 寄存器名字 `%xmrn0~%xmrn15` 来引用它们，每个 XMM 寄存器都是对应的 YMM 寄存器的低 128 位。

![媒体寄存器]({{ site.baseurl }}/picture/Pasted-image-20231011212841.png)

## 3.11.1 浮点传送和转换操作

图中给出了一组在内存和 XMM 寄存器之间以及从一个 XMM 寄存器到另一个不做任何转换的传送浮点数的指令，引用内存的指令是标量指令，意味着它们只对单个而不是一组封装好的数据值进行操作。数据要么保存在内存中（$M_{32}$ $M_{64}$），要么保存在 XMM 寄存器中（`X`）。无论数据对齐与否，这些指令都能正确执行，不过代码优化规则建议 32 位内存数据满足 4 字节对齐，64 位数据满足 8 字节对齐。内存引用的指定方式与整数 MOV 指令的一样。

![浮点数传送指令]({{ site.baseurl }}/picture/Pasted-image-20231011213828.png)

图中给出了在浮点数和整数数据类型之间以及不同浮点格式之间进行转换的指令集合。这些都是对单个数据值进行操作的标量指令。

- 双操作数浮点转换指令把一个从 XMM 寄存器或内存中读出的浮点值进行转换，并将结果写入一个通用寄存器。把浮点值转换成整数时，指令会执行截断（truncation），把值向 0 进行舍入。
- 三操作数浮点转换指令把整数转换成浮点数。它们使用的是不太常见的三操作数格式，有两个源和一个目的。第一个操作数读自于内存或一个通用目的寄存器。这里可以忽略第二个操作数，因为它的值只会影响结果的高位字节，而我们的目标必须是 XMM 寄存器。

![双操作数浮点转换指令]({{ site.baseurl }}/picture/Pasted-image-20231011213945.png)

![三操作数浮点转换指令]({{ site.baseurl }}/picture/Pasted-image-20231011214019.png)

## 3.11.2 过程中的浮点代码

- XMM 寄存器 `%xmm0~ %xmm7` 最多可以传递 8 个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。
- 函数使用寄存器 `%xmm0` 来返回浮点值。
- 所有的 XMM 寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中任意一个。

## 3.11.3 浮点运算操作

图中描述了一组执行算术运算的标量 AVX2 浮点指令。每条指令有一个（`S1`）或两（`S1` `S2`）源操作数，和一个目的操作数 `D`。第一个源操作数 `S1` 可以是一个 XMM 寄存器或一个内存位置。第二个源操作数和目的操作数都必须是 XMM 寄存器。每个操作都有一条针对单精度的指令和一条针对双精度的指令。结果存放在目的寄存器中。

![标量浮点算术运算]({{ site.baseurl }}/picture/Pasted-image-20231011213914.png)

## 3.11.4 定义和使用浮点常数

和整数运算操作不同，AVX 浮点操作不能以立即数值作为操作数。相反，编译器必须为所有的常量值分配和初始化空间。然后代码在把这些值从内存读入。

## 3.11.5 在浮点代码中使用位级操作

这些操作都作用于封装好的数据，即它们更新整个目的 XMM 寄存器，对两个源寄存器的所有位都实施指定的位级操作。

![对封装数据的位级操作]({{ site.baseurl }}/picture/Pasted-image-20231011220337.png)

## 3.11.6 浮点比较操作

这些指令类似于 `CMP` 指令，它们都比较操作数 `S1` 和 `S2`（但是顺序可能与预计的相反），并且设置条件码指示它们的相对值。参数 `S2` 必须在 XMM 寄存器中，而 `S1` 可以在 XMM 寄存器中或内存中。

浮点比较指令会设置三个条件码：零标志位 `ZF`、进位标志位 `CF` 和奇偶标志位 `P`。

![比较浮点数值的指令]({{ site.baseurl }}/picture/Pasted-image-20231011220511.png)

## 3.11.7 对浮点代码的观察结论

AVX2 为浮点数上的操作产生的机器代码风格类似千为整数上的操作产生的代码风格。它们都使用一组寄存器来保存和操作数据值，也都使用这些寄存器来传递函数参数。

AVX2 还有能力在封装好的数据上执行并行操作，使计算执行得更快。编译器开发者正致力于自动化从标量代码到并行代码的转换，但是目前通过并行化获得更高性能的最可靠的方法是使用 GCC 支持的、操纵向量数据的 C 语言扩展（SIMD）。

# 3.12 小结

在本章中，我们窥视了 C 语言提供的抽象层下面的东西，以了解机器级编程。通过让编译器产生机器级程序的汇编代码表示，我们了解了编译器和它的优化能力，以及机器、数据类型和指令集。

我们只分析了 C 到 x64 的映射，但是大多数内容对其他语言和机器组合来说也是类似的。例如，编译 C++ 与编译 C 就非常相似。实际上，C++ 的早期实现就只是简单地执行了从 C++ 到 C 的源到源的转换，并对结果运行 C 编译器，产生目标代码。C++ 的对象用结构来表示，类似于 C 的 struct。C++ 的方法是用指向实现方法的代码的指针来表示的。相比而言，Java 的实现方式完全不同。 Java 的目标代码是一种特殊的二进制表示，称为 Java 宇节代码。这种代码可以看成是虚拟机的机器级程序，其是用软件解释器处理字节代码，模拟虚拟机的行为。另外，有一种称为及时编译（just-in-time compilation）的方法，动态地将字节代码序列翻译成机器指令。当代码要执行多次时，这种方法执行起来更快。用字节代码作为程序的低级表示，优点是相同的代码可以在许多不同的机器上执行。