 #! https://zhuanlan.zhihu.com/p/658809262
# CSAPP 0x00 计算机系统漫游
# 1.1 信息就是位 + 上下文

`hello` 程序的生命周期是从一个源程序（或者说源文件）开始的，即程序员通过编辑器创建并保存的文本文件，文件名是 `hello.c` 。

源程序实际上就是一个由值 0 和 1 组成的**位**（又称为比特）序列，8个位被组织成一组，称为**字节**。每个字节表示程序中的某些文本字符。每个文本行都是以一个看不见的换行符 `\n` 来结束的，它所对应的整数值为 10 。

系统中所有的信息都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的**上下文**。

> 这里的文本字符是采用 ASCII 编码保存，常见的字符编码标准还有 UTF-8、UTF-16 等。

> ASCII 码是一种字符编码标准，它规定了 128 个字符的编码方式，包括英文字母、数字和一些符号等。ASCII 码使用 7 位二进制数表示一个字符，因此最多可以表示 128 个字符。而 Unicode 是一种字符集标准，它包含了世界上几乎所有的字符，包括各种语言的文字、符号和表情等。UTF-8 使用多个字节存储。

# 1.2 程序被其他程序翻译成不同的格式

为了在系统上运行 hello.c 程序，每条 C 语句都必须被其他程序转化为一系列的**低级机器语言指令**。然后这些指令按照一种称为**可执行目标程序**的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为**可执行目标文件**。

这个翻译过程可分为四个阶段完成，而执行这四个阶段的程序（**预处理器、编译器、汇编器和链接器**）一起构成了**编译系统（compilation system）**。

![编译系统]({{ site.baseurl }}/picture/Pasted-image-20230925112053.png)

- **预处理阶段**：预处理器（cpp）根据以字符 `＃` 开头的命令，修改源程序文本。结果就得到了另一个源程序文本，通常是以 `.i` 作为文件扩展名。
- **编译阶段**：编译器（eel）将文本文件 `.i` 翻译成文本文件 `.s` ，它包含一个汇编语言程序。该程序包含函数 `main` 的定义，定义中的每条语句都以一种文本格式描述了一条低级机器语言指令。
- **汇编阶段**：汇编器（as）将 `.s` 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件 `.o` 中。 `.o` 文件是 2 进制文件，它包含的是函数 `main` 的指令编码。如果我们在文本编辑器中打开 `.o` 文件，将看到一堆乱码.
- **链接阶段**：标准库中的一个函数存在于一个名为 `.o` 单独的预编译好了的目标文件中，链接器（Id）就负责处理这种合并，结果就得到一个可执行目标文件，可以被加载到内存中，由系统执行。

> 汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言且易于程序员理解。

# 1.3 了解编译系统如何工作是大有益处的

### 优化程序性能

现代编译器都是成熟的工具，通常可以生成很好的代码。但是，为了在程序中做出好的编码选择，我们确实需要了解一些机器代码以及编译器将不同的语旬转化为机器代码的方式。

- 一个 `switch` 语句是否总是比一系列 `else` 语旬高效得多？
- 一个函数调用的开销有多大?
- 指针引用比数组索引更有效吗？
- 为什么将循环求和的结果放到一个本地变量中，会比将其放到通过引用传递过来的参数中，运行起来快很多呢？
- 为什么我们只是简单地重新排列一 下算术表达式中的括号就能让函数运行得更快？

### 理解链接时出现的错误

一些*最令人困扰的程序错误*往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。

- 链接器报告说它无法解析一个引用，这是什么意思？
- 静态变量和全局变量的区别是什么？
- 静态库和动态库的区别是什么？
- 我们在命令行上排列库的顺序有什么影响？
- 为什么有些链接错误直到运行时才会出现？

### 避免安全漏洞

**缓冲区溢出错误**是造成大多数网络和互联网服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要*限制从不受信任的源接收数据的数量和格式*。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。

# 1.4 处理读并解释储存在内存中的指令

要想在 `Linux` 系统上运行可执行文件，我们将它的文件名输入到称为 `shell` 的应用程序中。

`shell` 是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的 `shell` 命令，那么 `shell` 就会假设这是一个可执行文件的名字，它将加载并运行这个文件。

### 1.4.1 系统的硬件组成

![一个典型系统的硬件组成]({{ site.baseurl }}/picture/Pasted-image-20230925112021.png)

#### 总线

贯穿整个系统的是一组电子管道，称作**总线**，它*携带信息字节并负责在各个部件间传递*。

通常总线被设计成传送定长的字节块，也就是**字（word）**。字中的字节数（即字长）是一 个基本的系统参数，各个系统中都不尽相同（4字节／8字节，主流为 64bit）。

#### I/O 设备

**I/O**（输入／输出）设备是*系统与外部世界的联系通道*。

每个 I/O 设备都通过一个**控制器**或**适配器**与总线相连。控制器和适配器之间的区别主要在于它们的封装方式，但无论如何，它们的功能都是在 I/O 总线和 I/O 设备之间传递信息。

- **控制器**是 I/O 设备本身或者系统的主印制电路板（通常称作主板）上的芯片组。
- **适配器**则是一块插在主板插槽上的卡。

#### 主存

**主存**是一个临时存储设备，在处理器执行程序时，用来*存放程序和程序处理的数据*。

- *物理*上来说，主存是由一组**动态随机存取存储器**（DRAM）芯片组成的。
- *逻辑*上来说，存储器是一个**线性的字节数组**，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。

#### 处理器

**中央处理单元（CPU）**，简称处理器，是*解释（或执行）存储在主存中指令的引擎*。

处理器的核心是一个大小为一个字的存储设备（或**寄存器**），称为**程序计数器**（PC）。在任何时刻，PC 都*指向主存中的某条机器语言指令*（即含有该条指令的地址）。

- **寄存器文件**（register file）是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。
- **算术逻辑单元**（ALU）是专门执行算术和逻辑运算的数字电路，其计算新的数据和地址值。

处理器看上去是按照一个非常简单的**指令执行模型**来操作的，这个模型是由**指令集架构**决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤：

- 处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行*该指令指示的简单操作*，然后更新 PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。

这样的简单操作并不多，它们围绕着主存、寄存器文件和算术／逻辑单元进行。下面是一些简单操作的例子：

- **加载**：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。
- **存储**：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。
- **操作**：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。
- **跳转**：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖 PC 中原来的值。

处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分开来。

- **指令集架构**描述的是每条机器代码指令的效果。
- **微体系结构**描述的是处理器实际上是如何实现的。

### 1.4.2 运行 hello 程序

- 当我们在键盘上输入字符串 `./hello` 后， `shell` 程序将字符逐一读入寄存器，再把它存放到内存中。

![从键盘上读取 hello 命令]({{ site.baseurl }}/picture/Pasted-image-20230925112127.png)

- 当我们在键盘上敲回车键时，`shell` 执行一系列指令来加载可执行的 `hello` 文件，这些指令将 `hello` 目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串。

> 利用**直接存储器存取**（DMA）技术，数据可以不通过处理器而直接从磁盘到达主存。

![从磁盘加载可执行文件到主存]({{ site.baseurl }}/picture/Pasted-image-20230925135824.png)

- 一旦目标文件中的代码和数据被加载到主存，处理器就开始执行程序中的机器指令。这些指令将 `hello, world\n` 字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。

![将输出字符串从储存器写到显示器]({{ site.baseurl }}/picture/Pasted-image-20230925135851.png)

# 1.5 高速缓存至关重要

系统花费了大量的时间把信息从一个地方挪到另一个地方。从程序员的角度来看，这些复制就是开销，减慢了程序 “真正” 的工作。因此，系统设计者的一个主要目标就是使这些复制操作尽可能快地完成。

- 根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。随着这些年半导体技术的进步，这种处理器与主存之间的差距还在持续增大。加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。
- `L1 L2 L3` 高速缓存是用一种叫做**静态随机访问存储器**（SRAM）的硬件技术实现的。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了*高速缓存的局部性原理*，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。

意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级。

![高速缓存存储器]({{ site.baseurl }}/picture/Pasted-image-20230925140521.png)

# 1.6 存储设备形成层次结构

每个计算机系统中的存储设备都被组织成了一个**存储器层次结构**。存储器层次结构的主要思想是上一层的存储器作为低层存储器的高速缓存。

正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。

![一个存储层次结构的示例]({{ site.baseurl }}/picture/Pasted-image-20230925112212.png)

# 1.7 操作系统管理硬件

程序都没有直接访问键盘、显示器、磁盘或者主存。取而代之的是，它们依靠操作系统提供的服务。

我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。

![计算机系统的分层视图]({{ site.baseurl }}/picture/Pasted-image-20230925112242.png)

操作系统有两个基本功能：

- 防止硬件被失控的应用程序滥用。
- 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。

操作系统通过几个基本的抽象概念（**进程、虚拟内存和文件**）来实现这两个功能。

![操作系统提供的抽象表示]({{ site.baseurl }}/picture/Pasted-image-20230925112317.png)

### 1.7.1 进程

**进程**是操作系统对一个*正在运行的程序的一种抽象*。

- 在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。
- 而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。
- 在大多数系统中，需要运行的进程数是多于可以运行它们的 CPU 个数的，先进的多核处理器同时能够执行多个程序。
- 无论是在单核还是多核系统中，一个 CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为**上下文切换**。

操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是**上下文**（如 PC 和寄存器文件的当前值，以及主存的内容）。

当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。

从一个进程到另一个进程的转换是由操作系统**内核**（kernel）管理的。 内核是*操作系统代码常驻主存的部分*。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的**系统调用**（system call）指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。

> 内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。

![进程的上下文切换]({{ site.baseurl }}/picture/Pasted-image-20230925112346.png)

### 1.7.2 线程

在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。

> 由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法。

### 1.7.3 虚拟内存

**虚拟内存**是一个抽象概念，它为每个*进程*提供了一个假象，即*每个进程都在独占地使用主存*。

每个进程看到的内存都是一致的，称为其**虚拟地址空间**。

在 `Linux` 中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据（图中的地址是从下往上增大的）。

每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。

- **程序代码和数据**：对所有的进程来说，代码是从同一固定地址开始，紧接着的是和全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，其在进程一开始运行时就被指定了大小。
- **堆**：堆可以在运行时动态地扩展和收缩。
- **共享库**：用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。
- **栈**：位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现*函数调用*。用户栈在程序执行期间可以动态地扩展和收缩。
- **内核虚拟内存**：地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。

虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。其基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。

![进程的虚拟地址空间]({{ site.baseurl }}/picture/Pasted-image-20230925112411.png)

### 1.7.4 文件

**文件**就是*字节序列*，仅此而已。

每个 `I/O` 设备，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为 `Unix I/O` 的系统函数调用读写文件来实现。

文件这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的 `I/O` 设备。

> **“一切皆是文件”** 是 Unix/Linux 的基本哲学之一。
# 1.8 系统间利用网络通信

现代系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个设备。

当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。

![利用 telent 通过网络远程运行 hello]({{ site.baseurl }}/picture/Pasted-image-20230925190350.png)

# 1.9 重要主题

## 1.9.1 Amdahl 定律

**Amdahl 定律**的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。Amdahl 定律描述了改善任何过程的一般原则。

## 1.9.2 井发和并行

有两个需求是驱动计算机进步的持续动力——我们想要计算机做得更多、我们想要计算机运行得更快。当处理器能够同时做更多的事情时，这两个因素都会改进。

- **并发（concurrency）**：指一个同时具有多个活动的系统。
- **并行（parallelism）**：指的是用并发来使一个系统运行得更快。

### 线程级并发

构建在进程这个抽象之上，我们能够设计出同时*有多个程序执行的系统*，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流 。

传统意义上，这种并发执行只是通过使一台计算机在它正在执行的进程间快速切换来模拟出来的。

![不同的处理器配置分类]({{ site.baseurl }}/picture/Pasted-image-20230925112459.png)

**多核处理器**是将多个 CPU（称为“核"）集成到一个集成电路芯片上。

- 首先，它减少了在执行多个任务时模拟并发的需要。
- 其次，它可以使应用程序运行得更快，当然，这必须要求程序是以多线程方式来书写的。

**超线程**，又称同时多线程（simultaneous multi-threading）, 是一项*允许一个 CPU 执行多个控制流*的技术。它涉及 CPU 某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算术运算的单元。常规的处理器需要大约 20000 个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得 CPU 能够更好地利用它的处理资源。

![多核处理器的架构]({{ site.baseurl }}/picture/Pasted-image-20230925112808.png)

### 指令级井行

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为**指令级并行**。

在流水线（pipelining）中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。

如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为**超标量（super-scalar）处理器**。

### 单指令、多数据并行

在最低层次上，许多现代处理器拥有特殊的硬件，*允许一条指令产生多个可以并行执行的操作*，这种方式称为单指令、多数据，即 **SIMD 并行**。  

提供这些 SIMD 指令多是为了*提高处理影像、声音和视频数据应用的执行速度*。虽然有些编译器会试图从程序中自动抽取 SIMD 并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如 GCC 就支持向量数据类型。

## 1.9.3 计算机系统中抽象的重要性

**抽象**的使用是计算机科学中最为重要的概念之一。

**虚拟机**：它提供对整个计算机的抽象，包括操作系统、处理器和程序。其最近才显示出其管理计算机方式上的优势，因为一些计算机必须能够运行为不同的操作系统或同一操作系统的不同版本设计的程序。

![计算机系统提供的一些抽象]({{ site.baseurl }}/picture/Pasted-image-20230925112829.png)

# 1.10 总结

计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是 ASCII 文本，然后被编译器和链接器翻译成二进制可执行文件。

处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O 设备和 CPU 寄存器之间复制数据，所以将系统中的存储设备划分成层次结构 CPU 寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM 主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化程序的性能。

操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象：

- 文件是对 I/O 设备的抽象；
- 虚拟内存是对主存和磁盘的抽象；
- 进程是处理器、主存和 I/O 设备的抽象。

最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种 I/O 设备。



